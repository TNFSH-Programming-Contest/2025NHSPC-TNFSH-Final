## 部落衝突 (tribe)
### 簡易題序
給你 $n$ 個點，每個點都有一個顏色 $C_i$，問你能不能把這 $n$ 個點連成一棵樹且恰好 $k$ 條邊的兩端是不同顏色。

### subtask 1 ($K = 0$)
觀察一下可以發現所有點都要是相同顏色才能達成，因為要是有不同顏色的兩個點，他們之間一定有至少一條邊連接不同顏色。

### subtask 2 ($K = N - 1$)
觀察一下可以發現如果所有點都相同顏色就不可能達成，否則我們可以選兩個不同顏色的點當代表，對於每個點都連到顏色不一樣的點上面就好。

### subtask 3 ($C_i \in \{1, 2\}$)
綜合 subtask 1, 2，我們可以推論出如果只有一種顏色，只有 $k = 0$ 才能滿足，如果兩種顏色都有，那只要 $k \ge 1$ 都能達成，我們可以用類似 subtask 2 的方式構造，先選兩個不同顏色的代表點連起來，接著如果目前還沒有 $k$ 條相異顏色的邊，那我們就把點連到相異顏色的代表點，如果已經有 $k$ 條了，那我們就把點連到相同顏色的代表點就好。

### subtask 4 (無額外限制)
延續 subtask 3，我們把所有顏色都拿一個點起來當代表，假設有 $c$ 種不同顏色，那 $k \ge c - 1$ 才會有解，因為我們一定要用 $c - 1$ 條不同顏色的邊將這 $c$ 種顏色連通，接著用 subtask 3 的構造方法，如果目前還沒有 $k$ 條相異顏色的邊，那我們就把點連到相異顏色的點，如果已經有 $k$ 條了，那我們就把點連到相同顏色的點就好。

## 切蛋糕 2 (cake2)
### 簡易題序
給你一個長度為 $n$ 的序列，你可以把它切成很多個區間，對於每個區間，如果那個區間長度小於 $k$ 分數為 $0$，否則你可以選擇把那個區間的分數設為 $0$ 或 那個區間的數字最小值，問你分數總和最大可以是多少。


### subtask 2 ($N \le 3000$)
和初選的 cake 那題做法差不多一樣。

我們定義 $dp[i]$ 為 : 只看 $1$ ~ $i$，分數總和最大會是多少。  
因此我們有轉移式 $$dp[i] = \max(dp[i - 1], \max_{1 \le j \le i - k}{(dp[j] + \min_{j < t \le i}{C_t})})$$
而最後 $dp[n]$ 即為答案

### subtask 3 ($|C_i| \le 1$)
不難想到一個貪心的做法，從左往右看，如果有連續 $k$ 個 $1$，那我們就把他給切出來。

### subtask 4 (無額外限制)
根據 subtask 3，可以想到一個貪心的結論，一定有一種最佳解切的區間長度都恰為 $k$。證明很簡單，這裡篇幅不夠就留給各位回去當練習了。

有了這個關鍵觀察，那我們就可以改寫 subtask 2 的 DP 式了

$$dp[i] = \max(dp[i - 1], dp[i - k] + \min_{i - k < t \le i}{C_t})$$

至於 $\min_{i - k < t \le i}{C_t}$ 可以用單調隊列或是稀疏表之類的資料結構快速維護。

## 手錶 (clock)
### 簡易題序
給 $n$ 個 $(A_i, B_i)$ 和 $M$，你每次操作可以從這 $n$ 個 pair 中選擇一個集合和一個整數 $k$，並將這個集合裡面的 $A_i$ 變為 $(A_i + k) \mod M$，每個 $A_i$ 最多只能被調整一次，問你最少要幾次操作才能讓所有 $A_i$ 大於等於 $B_i$。

### 30 分
(在每個子任務中，如果你輸出格式符合上述輸出格式，且調整後滿足所有 $A_i \ge B_i$，但並非是最少次調整 ( $T$ 並非最小) ，你可以獲得那個子任務的總分乘以 $0.3$ 的分數)。

我們可以直接花 $n$ 次調整，每次都把 $A_i$ 調到 $M - 1$ 就好

### subtask 1 ($A_i$ 皆相同)
很顯然如果所有 $A_i$ 一開始都大於等於 $B_i$ 就不用調整。

如果要調整，那我們將所有 $A_i$ 一起變為 $M - 1$ 就一定符合條件。

### subtask 2 ($M \le 5000$)
沒想到什麼特別的解法，為了讓子任務看起來很多而切的。

### subtask 3 ($B_i$ 皆相同)
同 subtask 2。

### subtask 4 (無額外限制)
不考慮那些 $A_i$ 一開始就大於等於 $B_i$ 的。  
我們觀察一下可以發現，每個可以選擇的 $k$ 的範圍為 $B_i - A_i \le k < M - A_i$。

因此我們可以轉換一下題目，給你 $n$ 個線段，每個線段為 $[B_i - A_i, M - A_i)$，你要選盡可能少的點，使得每個線段都被至少一個點覆蓋到。

我們可以對每條線段按右界排序的順序去看。  
我們維護一個集合 $S$。  
如果 $S$ 為空，那我們就把目前的線段丟進去 $S$。  
假設 $S$ 裡右界最小的線段叫 $A$，我們現在看的線段叫做 $B$。  
如果 $B$ 的左界和 $A$ 的右界有相交，那我們就把這個線段丟進 $S$ 裡。  
否則， $A$ 和 $B$ 一定不能在同一次選到，而因為 $S$ 裡所有線段都和 $A$ 的右界有相交，因此可以選那個右界來把 $S$ 裡的線段都一起處理掉。  

如果之後有一個線段 $X$ 能和 $A$ 這次一起處理掉，那那個線段 $X$ 也能和 $B$ 一起處理掉，因此這樣貪心會是對的。



## 隱藏的排列 (permutation)
### 簡易題序
互動題，有一個 $1$ 到 $n$ 的隱藏排列 $p$ ，每次你可以給兩個數字 $l, r$，詢問有多少數對 $(i, j)$ 滿足 $l \le i < j \le r$ 且 $p_i > p_j$ (以下稱為 $l, r$ 內的逆序數對數量)。

### subtask 1 ($n = 3$)
因為就 6 種可能的排列，我們觀察一下每個排列的問 (l, r) =  (1, 2), (2, 3), (1, 3) 分別會是多少  

1 2 3 -> (0, 0, 0)  
1 3 2 -> (0, 1, 1)  
2 1 3 -> (1, 0, 1)  
2 3 1 -> (0, 1, 2)  
3 1 2 -> (1, 0, 2)  
3 2 1 -> (1, 1, 3)  
可以發現如果問 (1, 2) 和 (1, 3)，這些排列對應的值兩兩相異，因此我們可以找到對應的那個排列

### 59.59 分 
我們觀察一下連續給分的公式，如果我們詢問所有合法的 $l, r$，那我們可以拿到這個分數。

如果我們知道了所有區間的逆序數對關係，那我們稍微排容一下就可以知道所有兩個數間的大小關係了，之後可以使用 std::sort 之類的方法來還原出隱藏的序列。


### subtask 2 (無額外限制)
觀察一下分數，要拿到滿分我們最多只能問 $n - 1$ 次。

我們可以從 $p_1$ 看到 $p_n$，在看到第 $p_i$ 時，我們只需要維護好 $p_1$ ~ $p_i$ 之間的大小關係就好，也就是在不改變相對關係的情況下我們把 $p_1$ ~ $p_i$ 重新編號成 $1$ ~ $i$。假設我們知道這東西了，那我們把 $[1, i + 1]$ 的逆序數對數量減去 $[1, i]$ 的逆序數對數量，就相當於 $[1, i]$ 中有幾個數大於 $p_{i + 1}$，假設叫做 $k$，那我們只要把原先維護好的 $i - k + 1$ 到 $i$ 全部 + 1，並將 $p_{i + 1}$ 設為 $i - k + 1$ 就能維護好了。

<!-- ## 賭博 (gambit)

### 簡易題序
給一個長度為 $n$ 的序列 $C$，有 $4$ 種操作
* $1$ $l$ $r$，把區間 $[l, r]$ 全部平方
* $2$ $l$ $r$，把區間 $[l, r]$ 全部乘 2
* $3$ $l$ $r$，把區間 $[l, r]$ 全部設為 0
* $4$ $x$ $k$ 詢問是否 $C_x \ge k$，並將 $C_x$ 設為 $\max(C_x - k, 0)$


### subtask 1 ($N, Q \le 5000$)
暴力做一做就好，小心溢位。

### subtask 2 (類型為 $1$ 的事件中 $l = r$)
蓋一棵能區間乘 $2$，區間設值的懶標線段樹就好

### subtask 3 (類型為 $4$ $x$ $k$ 事件中 $k = 10^9$)
讓你觀察到如果 $C_i$ 大於等於 $10^{14}$ 後我們就可以不用關心他的確切數值了。

### subtask 4 (無額外限制)
我們可以觀察到，區間乘 $2$，區間平方這些操作都會讓數值成長很快，每個位置大概只要 $50$ 次就會超過 $10^{14}$ 了，而區間設為 $0$ 這個操作只要做一次後那個位置就永遠都是 $0$ 了，因此對於每個操作，我們都可以暴力來完成。

因此我們可以維護三個 set，分別維護操作 $1$, $2$, $3$ 哪些地方需要改，如此一來暴力就做完了。

也可以用線段樹來維護。 -->

## 部落衝突 2 (tribe 2)

### 簡易題序
給你一棵樹，每個點都有一種顏色，有 $Q$ 比詢問。
每次詢問問你從 $A$ 到 $B$ 的路徑上第一個遇到顏色為 $C$ 的點是哪個。

### subtask 1 ($N, Q \le 2000$)
暴力

### subtask 2 ($U_i = i, V_i = i + 1$)
我們可以對每個顏色維護好有哪些點是這個顏色。
由於圖是一條練，如果 $A \le B$ 那我們可以用 lower_bound 來找到第一個顏色為 $C$ 且大於等於 $A$ 的點就好。
$A > B$ 同理。

### subtask 3 ($C_i \in \{1, 2\}$)
由於詢問沒有修改，因此我們可以離線來做，我們先處理完顏色為 $1$ 的再處理顏色為 $2$ 的。

對於目前要處理的顏色，相同顏色的點我們將那個點權設為 $1$，不同顏色的點權設為 $0$，如此一來我們可以用一條路徑的總和來看這條路徑上是否有出現相同顏色的點。

我們將 $A$ 到 $B$ 拆成 $A$ 到 $l$ 和 $l$ 到 $B$，其中 $l$ 是 $A$ 跟 $B$ 的最近共同祖先，如果 $A$ 到 $l$ 有顏色 $C$，那我們找第一個出現的就好，如果沒有，那我們再到 $B$ 到 $l$ 上找最後一個出現顏色為 $C$ 的點就好，而這些東西可以用倍增之類的方式來維護。

### subtask 4 (無額外限制)
延續 subtask 3，我們也是離線並且相同顏色的詢問一起處理，由於顏色很多，不可能每種顏色都建一個倍增表，我們需要一個能夠快速算出一條路徑上有多少東西並修改的資料結構。輕重鍊剖分完全符合這個條件。

但是輕重鍊剖分又大又難寫，提供一個比較好寫的方法。可以紀錄每個點 dfs 進入跟離開的時間 $in_i$ $out_i$ 做樹壓平，這樣有個性質是對於 $i$ 的子樹節點都會包含在 $in_i$ $out_i$ 之間，因此只要那個點要 + 1，我們可以在 $in_i$ 上 + 1， $out_i$ 上 - 1，如此一來，某個點 $i$ 到根節點上的路徑總和就可以用 $1$ 到 $in_i$ 的總和求得，因為需要修改，所以可以用二元索引樹(BIT)來維護。

如此一來我們就可以用 subtask 3 的方式求出答案了。

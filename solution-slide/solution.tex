\PassOptionsToPackage{dvipsnames}{xcolor}
\documentclass[hyperref,UTF8,notheorems,xcolor={dvipsnames}]{beamer}
\usepackage[dvipsnames]{xcolor}
\usetheme{Rochester}
\usepackage{amsmath, mathtools, graphicx}
\usepackage{standalone}
\usepackage[most]{tcolorbox}
\usepackage[normalem]{ulem}
\usepackage{xeCJK}
\usepackage{fontspec}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{pifont}
\usepackage{fontawesome5}
\usepgfplotslibrary{polar}
\usepgflibrary{shapes.geometric}
\usetikzlibrary{calc,angles,quotes}
\defaultfontfeatures{Mapping=tex-text}
\usefonttheme{professionalfonts}
\usepackage{concmath}
\usepackage{minted}

\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%

\newcommand{\CC}[1]{#1}

\newcommand{\Cincluded}{{\small\cmark}}
\newcommand{\Cdefine}{{\small\cmark\faFile*[regular]}}
\newcommand{\Ccodeonly}{{\small\cmark\faFile*~}}
\newcommand{\Cnofocus}{{\small\faQuestion}}
\newcommand{\Cexmaybe}{{\small\xmark\faQuestionCircle}}
\newcommand{\Cexcluded}{{\small\xmark}}

\newcommand{\Iincluded}{\item[\hbox to 1.8em{\Cincluded\hfill}]}
\newcommand{\Idefine}{\item[\hbox to 1.8em{\Cdefine\hfill}]}
\newcommand{\Icodeonly}{\item[\hbox to 1.8em{\Ccodeonly\hfill}]}
\newcommand{\Inofocus}{\item[\hbox to 1.8em{\Cnofocus\hfill}]}
\newcommand{\Iexmaybe}{\item[\hbox to 1.8em{\Cexmaybe\hfill}]}
\newcommand{\Iexcluded}{\item[\hbox to 1.8em{\Cexcluded\hfill}]}

\DeclareRobustCommand{\rddots}{\text{\reflectbox{$\ddots$}}}


\usepackage{graphicx}
\graphicspath{ {./../images/} }

\def\codesize{\fontsize{8}{9}\selectfont}
\setmonofont[Mapping=]{Source Code Pro}
\setminted{fontsize=\codesize, linenos, frame=lines, mathescape, autogobble, tabsize=4}
\setCJKmainfont[AutoFakeSlant,BoldFont=Noto Sans CJK TC Bold]{Noto Sans CJK TC}

\setlength{\parskip}{\baselineskip} 
\newcommand{\btitle}[1]{{\secname} -- #1}

\theoremstyle{definition}
\newtheorem{theorem}{定理}
\newtheorem{lemma}{引理}
\newtheorem{property}{性質}
\newtheorem{corollary}{推論}
\newtheorem{problem}{例題}


\newtheorem{definition}{定義}
\AtBeginEnvironment{definition}{
  \setbeamercolor{block title}{fg=white,bg=red!70!black}
  \setbeamercolor{block body}{fg=black, bg=block title.bg!10!bg}
}

\newtheorem{exercise}{習題}
\AtBeginEnvironment{exercise}{
  \setbeamercolor{block title}{fg=white,bg=green!30!black}
  \setbeamercolor{block body}{fg=black, bg=block title.bg!10!bg}
}


\AtBeginSection[]{
%   \begin{frame}
%     \tableofcontents[currentsection,hideallsubsections]
%   \end{frame}
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=6pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\LARGE\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}


\AtBeginSubsection[]{
  \begin{frame}
    \tableofcontents[subsectionstyle=show/shaded/hide]
  \end{frame}
}

\usepackage{ctable}
\usepackage{tabularx}

\setlength{\parskip}{\baselineskip}


\title{114 臺南一中學科能力競賽校內複選}

\hypersetup{CJKbookmarks=true}
\begin{document}

\author{題解}
\date{Sep 25 2025}

\begin{frame}
	\titlepage
\end{frame}

\section*{Overview}

\begin{frame}[fragile]{\btitle{預期解出人數}}
	預測校隊線 : \textcolor{blue}{400}
	\begin{center}
		\begin{tikzpicture}
			\begin{axis} [%
				ybar,
				bar width=12pt,
				xmin=0.5,
				xmax=6.5,
				ymin=0,
				xtick={1,2,3,4,5,6},
				xticklabels={A,B,C,D,E,F}]
			\addplot plot coordinates {
				(1,8) 
				(2,1) 
				(3,5)
				(4,4)
				(5,10)
				(6,1)
			};
			
			\addplot [color=white] plot coordinates {
				(1,1) 
				(2,1) 
				(3,1) 
				(4,1)
				(5,1)
				(6,1)
			};
			\end{axis}
		\end{tikzpicture}
	\end{center}
\end{frame}

\begin{frame}[fragile]{\btitle{實際解出人數}}
	預測複選線 : \textcolor{blue}{400}  實際複選線 : \textcolor{red}{0}
	\begin{center}
		\begin{tikzpicture}
			\begin{axis} [%
				ybar,
				bar width=12pt,
				xmin=0.5,
				xmax=6.5,
				ymin=0,
				xtick={1,2,3,4,5,6},
				xticklabels={A,B,C,D,E,F}]
			\addplot plot coordinates {
				(1,8) 
				(2,1) 
				(3,5)
				(4,4)
				(5,10)
				(6,1)
			};
			\addplot plot coordinates {
				(1,1) 
				(2,1) 
				(3,1) 
				(4,1)
				(5,1)
				(6,1)
			};
			\end{axis}
		\end{tikzpicture}
	\end{center}
\end{frame}

\section{出題者想說的 和 Fun Fact}

\begin{frame}[fragile]{\btitle{前言}}
	\item 出題出很久，希望大家都有好好打
	\pause
	\item 希望測資不要爛掉

\end{frame}

\begin{frame}[fragile]{\btitle{Fun Fact --- pB}}
	\begin{itemize}
		\item 本來 $K > 1$，初選過發現大家都好強趕緊加難
		\pause
		\item 出題者自己在這題燒雞超久
		\pause
		\item 花了 3 小時暴力跑對拍，測資應該沒錯
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{\btitle{Fun Fact --- pE}}
	\begin{itemize}
		\item 加難 pB 後發現整體題目好難，趕緊重出一題簽到題
		\pause
		\item 希望沒有人被範圍騙到
	\end{itemize}
\end{frame}


\begin{frame}[fragile]{\secname}
	\begin{enumerate}
		\item A : 構造題
		\item B : DP + 優化
		\item C : 貪心
		\item D : greedy
		\item E : 排列組合
		\item F : 樹論
	\end{enumerate}
\end{frame}

\section{A. 部落衝突 (tribe)}


\begin{frame}[fragile]{\btitle{題目敘述}}
	給你 $n$ 個點，每個點都有一個顏色 $C_i$，問你能不能把這 $n$ 個點連成一棵樹且恰好 $k$ 條邊的兩端是不同顏色。
\end{frame}

\begin{frame}[fragile]{\btitle{子任務}}
	\begin{enumerate}
		\item $K = 0$
		\item $K = N - 1$
		\item $C_i \in \{1, 2\}$
		\item 無額外限制
	\end{enumerate}
\end{frame}

\begin{frame}[fragile]{\btitle{子任務 1 --- $K = 0$}}
	觀察一下可以發現所有點都要是相同顏色才能達成。 
	\pause

	因為要是有不同顏色的兩個點，他們之間一定有至少一條邊連接不同顏色。
\end{frame}

\begin{frame}[fragile]{\btitle{子任務 2 --- $K = N - 1$}}
	觀察一下可以發現如果所有點都相同顏色就不可能達成。 
	\pause

	否則我們可以選兩個不同顏色的點當代表，對於每個點都連到顏色不一樣的點上面就好。
\end{frame}

\begin{frame}[fragile]{\btitle{子任務 3 --- $C_i \in \{1, 2\}$}}
	綜合 subtask 1, 2，我們可以推論出如果只有一種顏色，只有 $k = 0$ 才能滿足。

	如果兩種顏色都有，那只要 $k \ge 1$ 都能達成，我們可以用類似 subtask 2 的方式構造。 \\
	先選兩個不同顏色的代表點連起來，接著如果目前還沒有 $k$ 條相異顏色的邊，那我們就把點連到相異顏色的代表點，如果已經有 $k$ 條了，那我們就把點連到相同顏色的代表點就好。
\end{frame}

\begin{frame}[fragile]{\btitle{子任務 4 --- 無額外限制}}
	延續 subtask 3，我們把所有顏色都拿一個點起來當代表。 

	假設有 $c$ 種不同顏色，那 $k \ge c - 1$ 才會有解，因為我們一定要用 $c - 1$ 條不同顏色的邊將這 $c$ 種顏色連通。
	\pause

	接著用 subtask 3 的構造方法，如果目前還沒有 $k$ 條相異顏色的邊，那我們就把點連到相異顏色的點，如果已經有 $k$ 條了，那我們就把點連到相同顏色的點就好。
\end{frame}

\section{B. 分蛋糕 2(cake2)}

\begin{frame}[fragile]{\btitle{題目敘述}}
	我們定義一個合法的切蛋糕方式為一系列的區間 $(l_1, r_1), (l_2, r_2), ..., (l_k, r_k)$ 滿足 $l_1 = 1$, $r_k = n$，並且對於所有 $1 \le i \le k$ 都有 $l_i \le r_i$，且對於所有 $1 \le i < k$，都有 $r_i + 1 =  l_{i + 1}$。
	而這個切蛋糕方式所得到的好感值總和為 
	$$
	\sum_{t = 1}^{k}{\begin{cases}
	0 & \text{if  } r_t - l_t + 1 < K \\
	\min_{l_t \le i \le r_t} C_i & \text{otherwise  }
	\end{cases}}
	$$
	我們要找出所有合法的切蛋糕方式中好感值總和最大的是多少。
\end{frame}

\begin{frame}[fragile]{\btitle{子任務}}
	\begin{enumerate}
		\item $N \le 3000$
		\item $K > 1$
		\item $|C_i| \le 1$
		\item 無額外限制
	\end{enumerate}
\end{frame}

\begin{frame}[fragile]{\btitle{子任務 1 --- $N \le 3000$}}
	如果你有寫出初選的 pD，那你應該要會這個子任務
	\pause

	我們定義 $dp[i]$ 為 : 只看 $1$ ~ $i$，分數總和最大會是多少。  
	因此我們有轉移式 $$dp[i] = \max(dp[i - 1], \max_{1 \le j \le i - k}{(dp[j] + \min_{j < t \le i}{C_t})})$$
	而最後 $dp[n]$ 即為答案
\end{frame}

\begin{frame}[fragile]{\btitle{子任務 2 --- $K > 1$}}
	可以想到一個貪心的結論，一定有一種最佳解切的區間長度都為 $K$ 或 $1$
	\pause

	證明很簡單，這裡篇幅不夠就留給各位回去當練習了。

	因此我們轉移式就可以用單調對列之類的資料結構 $O(n)$ 轉移了
\end{frame}

\begin{frame}[fragile]{\btitle{子任務 3 --- $|C_i| \le 1$}}
	我們不能切大小為 $1$ 的區間讓貢獻讓負的變成 $0$ 了。
	\pause

	可以觀察到，其實 $0$ 很沒用，他在
\end{frame}

\begin{frame}[fragile]{\btitle{子任務 4 --- 無額外限制}}
	
\end{frame}

\section{C. 隱藏的排列 (permutation)}

\begin{frame}[fragile]{\btitle{題目敘述}}
	互動題，有一個 $1$ 到 $n$ 的隱藏排列 $p$ ，每次你可以詢問 $p_i - p_j$ 是多少，花 $n - 1$ 次以內的詢問還原出那個序列。
\end{frame}

\begin{frame}[fragile]{\btitle{子任務}}
	\begin{enumerate}
		\item $n = 3$
		\item $p_1 = 1$
		\item 無額外限制
	\end{enumerate}
\end{frame}

\begin{frame}[fragile]{\btitle{子任務 1 --- $n = 3$}}
	因為就 3! 種可能的排列，我們觀察一下每一個排列的 $p_2 - p_1$ 和 $p_3 - p_1$ 是多少 
	\pause

	1 2 3 -> (1, 2)  \\
	1 3 2 -> (2, 1)  \\
	2 1 3 -> (-1, 2)  \\
	2 3 1 -> (1, -2)  \\
	3 1 2 -> (-2, 1)  \\
	3 2 1 -> (-1, -1)
	\pause

	可以發現兩兩相異，因此我們可以用這兩個詢問找到對應的那個排列。
\end{frame}

\begin{frame}[fragile]{\btitle{子任務 2 --- $p_1 = 1$}}
	如果我們知道了 $p_i - p_1 = k$，那麼我們就可以推得 $p_i = p_1 + k$ 了。
	
	又知道 $p_1 = 1$，因此就可以算出所有 $p_i$ 了。
\end{frame}

\begin{frame}[fragile]{\btitle{子任務 3 --- 無額外限制}}
	我們先假設 $p_1 = 0$，如此可以用 subtask 2 的方法得出一個排列，我們假設叫 $q$。
	\pause

	舉例來說，那個隱藏的序列 $p$ 是 [2 4 1 5 3]，那我們得到的 $q$ 會是 [0 2 -1 3 1]。
	\pause

	我們可以觀察到 $p$ 和 $q$ 的最小值會發生在同個位置，因此 $q$ 最小值那個地方在 $p$ 中會是 $1$。
	
	因此我們只要將這個 $q$ 全部加上 $1$ - ($q$ 的最小值) 就會變成 $p$ 了。

\end{frame}



\section{D.  切蛋糕 (cake)}

\begin{frame}[fragile]{\btitle{題目敘述}}
	給你一個長度為 $n$ $(n \le 3000)$ 的序列，你可以把它切成很多個區間。
	
	對於每個區間，你可以選擇把那個區間的分數設為 $0$ 或 那個區間的數字總和乘以區間長度，問你分數總和最大可以是多少。
\end{frame}

\begin{frame}[fragile]{\btitle{子任務}}
	\begin{enumerate}
		\item $C_i$ 皆相同
		\item 無額外限制
	\end{enumerate}
\end{frame}

\begin{frame}[fragile]{\btitle{子任務 1 --- $C_i$ 皆相同}}
	可以觀察到不要切一定會最好。
\end{frame}

\begin{frame}[fragile]{\btitle{子任務 2 --- 無額外限制}}
	我們定義 $dp[i]$ 為 : 只看 $1$ 到 $i$，分數總和最大會是多少。  
	\pause

	因此我們有轉移式 $$dp[i] = \max(dp[i - 1], \max_{1 \le j < i}{(dp[j] + sum(j + 1, i) \times (i - j))})$$

	其中 $sum(j + 1, i)$ 為 $j + 1$ 到 $i$ 的數字總和，可以用前綴和快速查詢。

	而最後 $dp[n]$ 即為答案

\end{frame}


\section{E. 地震 (earthquake)}

\begin{frame}[fragile]{\btitle{題目敘述}}
	給你一個長度為 $n$ 的序列 $h$，有 $q$ 個事件  \\
	$1$ $l$ $r$ $c$ : 對 $l$ 到 $r$ 都加上 $c$  \\
	$2$ $a$ $b$ : 問你有多少整數 $i$ 滿足 $a \le i < b$ 且 $h_i < h_{i + 1}$
\end{frame}

\begin{frame}[fragile]{\btitle{子任務}}
	\begin{enumerate}
		\item 不會有 $1$ $L$ $R$ $C$ 類型的事件
		\item 所有 $2$ $A$ $B$ 的事件中 $A = 1, B = N$
		\item 所有 $1$ $L$ $R$ $C$ 的事件中 $L = R$
		\item 無額外限制
	\end{enumerate}
\end{frame}

\begin{frame}[fragile]{\btitle{子任務 1 --- 不會有 $1$ $L$ $R$ $C$ 類型的事件}}
	
	開一個陣列 $p$，接著對於第 $h_i < h_{i + 1}$ 的所有 $i$，我們在 $p_i$ 上加 $1$，詢問時就相當於問 $p_l + ... + p_{r - 1}$ 的值，可以用前綴和快速回答。

\end{frame}

\begin{frame}[fragile]{\btitle{子任務 2 --- 所有 $2$ $A$ $B$ 的事件中 $A = 1, B = N$}}
	
	可以觀察到，若出現第 $1$ 種操作，那 subtask 1 所述的陣列 $p$ 只會在 $a - 1$ 及 $b$ 的位置有可能發生改變，因此我們只要看這兩個位置有沒有改變就好。

\end{frame}

\begin{frame}[fragile]{\btitle{子任務 3 --- 所有 $1$ $L$ $R$ $C$ 的事件中 $L = R$}}
	
	根據 subtask 1 和 2，我們可以發現這個陣列 $p$ 會需要修改，因此我們可以使用二元索引樹(BIT) 等資料結構來維護這個陣列 $p$。 

\end{frame}

\begin{frame}[fragile]{\btitle{子任務 4 --- 無額外限制}}
	
	綜合上述子任務，我們還需要快速知道某個位置目前的值是多少，因此可以使用差分來維護陣列 $h$，這樣也可以使用二元索引樹來快速維護。

\end{frame}


\section{F. 忠孝東路走一遍 (road)}

\begin{frame}[fragile]{\btitle{題目敘述}}
	給你一個序列 $C$ 和 $X$, $Y$, $Z$，你一開始在 $1$ 上。

	移動有兩種方式 : 

	\begin{enumerate}
		\item 花 $X$ 元從 $i$ 移動到 $i - 1$ 或 $i + 1$ \\
		\item 選一個 $C_i = C_j$ 的 $j$ 並花 $Y$ 元從 $i$ 移動到 $j$
	\end{enumerate}

	對於第二種移動方式，有一個 $Z$ $(Z \le 2 Y)$ 元的優惠券，使用 $t$ 次第二種移動方式花的實際金錢為 $\max(0, t \times Y - Z)$

	對於 $k = 1, 2, ..., n$ 問你從 $1$ 走到 $k$ 再從 $k$ 走到 $n$ 最小花費是多少。
\end{frame}

\begin{frame}[fragile]{\btitle{子任務}}
	\begin{enumerate}
		\item $C_i$ 皆相同
		\item 對於所有 $k$，滿足 $C_i = k$ 的 $i$ 的數量不會超過 $2$ 個
		\item $Z = 0$
		\item 無額外限制
	\end{enumerate}
\end{frame}

\begin{frame}[fragile]{\btitle{子任務 1 --- $C_i$ 皆相同}}
	枚舉 $1$ 到 $k$ 和 $k$ 到 $n$ 分別是用哪種移動方式就好。
\end{frame}

\begin{frame}[fragile]{\btitle{子任務 2 --- 對於所有 $k$，滿足 $C_i = k$ 的 $i$ 的數量不會超過 $2$ 個}}
	首先，我們偷偷的在這個子任務再加個 $Z = 0$ 的條件。

	我們可以直接把每個街區視為點，然後每個點可以到達的所有街區建一條邊，由於圖的邊是雙向的，從 $1$ 到 $k$ 再從 $k$ 到 $n$ 的最短路徑，相當於從 $1$ 到 $k$ 加上從 $n$ 到 $k$ 的最短路徑。
	
	因此我們只要從點 $1$ 和點 $n$ 跑一次 dijkstra 後就可以得出了。
\end{frame}

\begin{frame}[fragile]{\btitle{子任務 2 --- 對於所有 $k$，滿足 $C_i = k$ 的 $i$ 的數量不會超過 $2$ 個}}
	但是這子任務沒有保證 $Z = 0$，因為題目限制 $Z \le 2Y$，因此我們對每個點都記錄用了 $0$ 次，$1$ 次，或 $2$ 次以上的第二種移動方式到這個點的最短路徑。
	\pause
	
	如此一來我們分別枚舉 $1$ 到 $k$ 和 $k$ 到 $n$ 分別用了幾次第二種移動方式的所有可能，取個最小值就是答案了。
\end{frame}

\begin{frame}[fragile]{\btitle{子任務 3 --- $Z = 0$}}
	
	如果用 subtask 2 第一頁寫的那個方式做會遇到一個問題，如果我們每個點可以到達的所有街區都建一條邊，那邊的數量最多有 $O(n^2)$ 條。
	\pause

	我們可以對每個 $C_i$ 都建一條超級點，對於所有相同 $C_i$ 的點，我們建一條邊權為 $Y$ 的邊到那個超級點，再建一條邊權為 $0$ 的邊回來就好，這樣邊的數量就會是 $O(n)$ 條的。
	
\end{frame}

\begin{frame}[fragile]{\btitle{子任務 4 --- 無額外限制}}
	綜合 subtask 2, 3 就可以做出來了。
\end{frame}

\end{document}